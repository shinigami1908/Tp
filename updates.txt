def _is_numeric_like(value: Any) -> bool:
    """
    Helper to decide if a value is effectively numeric (int/float or numeric string).
    We use this to drop 'raw' numeric aggregates from the GPT payload, except KPI fields.
    """
    if isinstance(value, (int, float)):
        return True
    if isinstance(value, str):
        s = value.strip()
        if s == "":
            return False
        try:
            float(s)
            return True
        except ValueError:
            return False
    return False


def _compact_report_for_gpt(report: Dict[str, Any]) -> Dict[str, Any]:
    """
    Build a lighter version of a single employee report for GPT:

    - Keep identity / context: employee_id, name, role, org, manager_id.
    - In `periods`:
        * Always keep period_half.
        * Keep ALL list/dict fields (usually text arrays, red-flag structures, etc.).
        * Keep non-numeric scalars (strings/bools).
        * For numeric-like fields, KEEP ONLY those whose key starts with 'kpi__'.
    - In `combined_extra`:
        * Same rule: keep text/bool/list/dict, plus numeric 'kpi__*' fields.

    This does NOT mutate the original report; it returns a new dict.
    """
    core_keys = ["employee_id", "name", "role", "org", "manager_id"]

    compact: Dict[str, Any] = {}

    # Top-level core info
    for k in core_keys:
        if k in report:
            compact[k] = report[k]

    # Periods
    compact_periods: List[Dict[str, Any]] = []
    for period in report.get("periods", []) or []:
        new_p: Dict[str, Any] = {}
        for key, val in period.items():
            # Ignore any stray employee_id inside period rows
            if key == "employee_id":
                continue

            # Always keep the period identifier
            if key in ("period_half", "period", "period_label"):
                new_p[key] = val
                continue

            # Preserve lists/dicts â€“ these are often structured text or red-flag info
            if isinstance(val, (list, dict)):
                new_p[key] = val
                continue

            # Numeric-like?
            if _is_numeric_like(val):
                # Only keep numeric KPI-style fields
                if isinstance(key, str) and key.startswith("kpi__"):
                    new_p[key] = val
                # else: drop raw aggregates from GPT payload
                continue

            # Non-numeric scalar (string/bool/etc.) â†’ keep
            new_p[key] = val

        if new_p:
            compact_periods.append(new_p)

    compact["periods"] = compact_periods

    # combined_extra
    combined_extra = report.get("combined_extra", {}) or {}
    new_combined: Dict[str, Any] = {}

    for key, val in combined_extra.items():
        # Preserve lists/dicts
        if isinstance(val, (list, dict)):
            new_combined[key] = val
            continue

        # Numeric-like?
        if _is_numeric_like(val):
            if isinstance(key, str) and key.startswith("kpi__"):
                new_combined[key] = val
            continue

        # Non-numeric scalar
        new_combined[key] = val

    compact["combined_extra"] = new_combined

    return compact


def _build_compact_reports_for_gpt(reports: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Build a compact version of all reports for GPT by applying _compact_report_for_gpt
    to each full report.
    """
    return [_compact_report_for_gpt(r) for r in reports]




manager_reports = build_manager_reports(manager_id, base_dir=base_dir)
if not manager_reports:
    log.error("No report cards found for manager_id=%s", manager_id)
    return {"status": "error", "detail": "No report cards for manager"}

# Sort by employee_id for deterministic order
manager_reports = sorted(
    manager_reports,
    key=lambda r: str(r.get("employee_id") or "")
)

# ðŸ”´ NEW: build compact copy for GPT payload
compact_reports = _build_compact_reports_for_gpt(manager_reports)

# Only the compact version goes in the prompt
reports_json = json.dumps(compact_reports, indent=2, default=str)

tcm = TachyonChatManager()

system_msg = {
    "role": "system",
    "content": MANAGER_INSIGHTS_SYSTEM_PROMPT,
}

user_content = MANAGER_INSIGHTS_USER_PROMPT_TEMPLATE.format(
    manager_id=manager_id,
    report_data=reports_json,
)

user_msg = {
    "role": "user",
    "content": user_content,
}
