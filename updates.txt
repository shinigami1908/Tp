# --- REPLACE/UPDATE this helper in src/etl/json_exporter.py ---

def _row_to_simple(obj):
    """
    Convert objects not JSON-serializable (pandas.Timestamp, pandas.NaT, numpy scalars, NaN)
    into simple Python types.
    """
    # handle pandas NaT / numpy NaN early
    try:
        import pandas as _pd
        import numpy as _np
    except Exception:
        _pd = None
        _np = None

    # pandas NaT or numpy NaN -> None
    try:
        if _pd is not None and (_pd.isna(obj) or obj is _pd.NaT):
            return None
    except Exception:
        # pd.isna may fail for some exotic types - ignore
        pass

    # pandas Timestamp -> ISO string
    try:
        if _pd is not None and isinstance(obj, _pd.Timestamp):
            if pd.isna(obj):
                return None
            return obj.isoformat()
    except Exception:
        pass

    # pandas Timedelta -> string
    try:
        if _pd is not None and isinstance(obj, _pd.Timedelta):
            return str(obj)
    except Exception:
        pass

    # numpy scalar types -> Python scalars
    try:
        if _np is not None and isinstance(obj, (_np.generic,)):
            return obj.item()
    except Exception:
        pass

    # builtin floats that are nan
    try:
        import math
        if isinstance(obj, float) and math.isnan(obj):
            return None
    except Exception:
        pass

    # fallback: return as-is (serializer fallback will handle remaining)
    return obj





# inside write_single_combined_json(...), where you iterate emp_obj

# Example for uncompressed file (same logic applies to gzip branch)
with open(target, "w", encoding="utf-8") as fh:
    fh.write('{"employees": [')
    first = True
    for emp_obj in _iter_employee_objects(loaded, include_raw=include_raw):
        # ensure nested values are converted using _row_to_simple already when building emp_obj,
        # but we still guard here against unexpected types
        try:
            s = json.dumps(emp_obj, ensure_ascii=False)
        except Exception:
            # log and try a tolerant serialization
            try:
                s = json.dumps(emp_obj, default=str, ensure_ascii=False)
                log.warning("json_exporter: fallback-serialized employee_id=%s using default=str", emp_obj.get("employee_id"))
            except Exception as e2:
                # ultimate fallback: write minimal safe object and log exception
                log.exception("json_exporter: failed to serialize employee_id=%s; writing placeholder. Error: %s", emp_obj.get("employee_id"), e2)
                s = json.dumps({"employee_id": emp_obj.get("employee_id"), "serialization_error": True}, ensure_ascii=False)

        if not first:
            fh.write(",\n")
        fh.write(s)
        fh.flush()          # make progress visible on disk immediately
        first = False
    fh.write("]}")
