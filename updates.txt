# src/etl/periodizer.py
"""
Periodizer: attach/normalize 'period_half' column on incoming DataFrames.

Special behavior:
 - If key_hint == "idp_goals": do NOT infer period from target_date; missing period_half -> "NA"
 - Otherwise keep the flexible inference rules:
     - H1/H2 -> DEFAULT_YEAR + H1/H2
     - YYYYH1/ YYYYH2 preserved
     - 'sprint' like "2025H1-S3" -> "2025H1"
     - 'month' YYYY-MM parsed to date -> infer half by month
     - fallback attempt from common date columns
     - remaining missing -> "unknown"
"""
import re
from typing import Optional
import pandas as pd
from ..common.logger import get_logger

log = get_logger("periodizer")

DEFAULT_YEAR = 2025

_sprint_re = re.compile(r"(?P<period>\d{4}H[12])", flags=re.IGNORECASE)
_yearhalf_re = re.compile(r"(?P<year>\d{4})\s*[ -_]?H(?P<half>[12])", flags=re.IGNORECASE)


def _normalize_h1h2(value: str) -> Optional[str]:
    if value is None:
        return None
    v = str(value).strip()
    if not v:
        return None
    # direct YYYYH1 or YYYY H1 like forms
    m = _yearhalf_re.search(v)
    if m:
        year = m.group("year")
        half = m.group("half")
        return f"{year}H{half}"
    # simple H1 / H2 (no year) -> assume DEFAULT_YEAR
    if v.upper() in ("H1", "H2"):
        return f"{DEFAULT_YEAR}{v.upper()}"
    # already looks like 2025H1
    if re.match(r"^\d{4}H[12]$", v, flags=re.IGNORECASE):
        return v.upper()
    return None


def _infer_from_sprint(s: str) -> Optional[str]:
    if s is None:
        return None
    s = str(s)
    m = _sprint_re.search(s)
    if m:
        return m.group("period").upper()
    if "H1" in s.upper():
        return f"{DEFAULT_YEAR}H1"
    if "H2" in s.upper():
        return f"{DEFAULT_YEAR}H2"
    return None


def _infer_from_date_value(val) -> Optional[str]:
    if val is None:
        return None
    try:
        ts = pd.to_datetime(val, errors="coerce", infer_datetime_format=True)
        if pd.isna(ts):
            return None
        year = ts.year
        month = ts.month
        half = "H1" if month <= 6 else "H2"
        return f"{year}{half}"
    except Exception:
        return None


def attach_period_half(df: pd.DataFrame, key_hint: Optional[str] = None) -> pd.DataFrame:
    """
    Attach/normalize a `period_half` column to the dataframe.

    key_hint: optional string indicating which table this is (e.g., "idp_goals", "jira_metrics").
    """
    if df is None:
        return df
    df = df.copy()

    # If idp_goals, special-case: do not infer from target_date; set missing -> "NA"
    is_idp = bool(key_hint and str(key_hint).lower() == "idp_goals")

    # Ensure period_half column exists
    if "period_half" not in df.columns:
        df["period_half"] = pd.NA

    # 1) Normalize explicit period or period_half values first
    df["period_half"] = df["period_half"].apply(lambda v: _normalize_h1h2(v) or (str(v).strip() if pd.notna(v) and str(v).strip() else pd.NA))

    # If there is a 'period' column, use it only to fill missing period_half
    if "period" in df.columns:
        mask = df["period_half"].isna()
        if mask.any():
            df.loc[mask, "period_half"] = df.loc[mask, "period"].apply(lambda v: _normalize_h1h2(v) or pd.NA)

    # 2) For sprint column (jira), fill where missing
    if "sprint" in df.columns:
        mask = df["period_half"].isna()
        if mask.any():
            df.loc[mask, "period_half"] = df.loc[mask, "sprint"].apply(lambda v: _infer_from_sprint(v) or pd.NA)

    # 3) month column YYYY-MM (common in rto / github month)
    if "month" in df.columns:
        mask = df["period_half"].isna()
        if mask.any():
            def from_month_val(v):
                try:
                    if pd.isna(v):
                        return None
                    s = str(v).strip()
                    if re.match(r"^\d{4}-\d{1,2}$", s):
                        return _infer_from_date_value(s + "-01")
                    return _infer_from_date_value(s)
                except Exception:
                    return None
            df.loc[mask, "period_half"] = df.loc[mask, "month"].apply(from_month_val)

    # 4) If this is IDP goals, DO NOT infer from target_date; set missing explicitly to "NA"
    if is_idp:
        # preserve any explicit period_half already present; otherwise set to 'NA'
        df["period_half"] = df["period_half"].fillna("").astype(str).str.strip()
        df.loc[df["period_half"] == "", "period_half"] = "NA"
        # done for idp
        log.info("attach_period_half: key_hint=idp_goals -> missing period_half set to 'NA' (no date inference).")
        return df

    # 5) For non-IDP tables, infer from date-like columns where still missing
    date_columns_priority = ["date", "completion_date", "created_at", "timestamp", "target_date", "manager_timestamp"]
    for col in date_columns_priority:
        if col in df.columns:
            mask = df["period_half"].isna()
            if not mask.any():
                break
            df.loc[mask, "period_half"] = df.loc[mask, col].apply(lambda v: _infer_from_date_value(v))

    # Replace any remaining NaN/empty with explicit "unknown"
    df["period_half"] = df["period_half"].fillna("").astype(str).str.strip()
    df.loc[df["period_half"] == "", "period_half"] = "unknown"

    # Final normalization: map plain H1/H2 to DEFAULT_YEAR and ensure case
    def _final_norm(val):
        if val is None:
            return "unknown"
        v = str(val).strip()
        if v.lower() == "unknown" or v == "":
            return "unknown"
        if v.upper() in ("H1", "H2"):
            return f"{DEFAULT_YEAR}{v.upper()}"
        if re.match(r"^\d{4}H[12]$", v, flags=re.IGNORECASE):
            return v.upper()
        return "unknown"

    df["period_half"] = df["period_half"].apply(_final_norm)

    # Log summary
    try:
        counts = df["period_half"].value_counts(dropna=False).to_dict()
        log.info("attach_period_half(%s) produced period counts: %s", key_hint or "", counts)
    except Exception:
        pass

    return df
